0. Overall goal

A neutral, abstract map editor, mostly human-driven, that:

Works with a Voronoi-like tiling as the base.

Lets you define generic zone types (forest, desert, “Zone A”, “Danger”, etc).

Has generic paths (roads, rivers, currents, story links).

Has generic structures (buildings, points of interest) that can be grouped.

Handles zoom nicely (constant line width, optional merging at low zoom).

Exports to SVG and a human-readable custom format.

Later: optional generative modes that never overwrite user-defined landmarks.

Think “Google Maps / OpenStreetMap style” but completely under your control and semantically neutral.

1. Core conceptual model
1.1 Base geometry: Voronoi cells

The world is a bounded 2D plane (for example 0..1 in both x and y).

We maintain a list of sites: points in this plane.

A Voronoi diagram is built from these sites, and each site owns one cell (a polygon).

There is an option to make placement modes:

Pure random.

“Even” distribution (Poisson disk or jittered grid) that can approximate a grid.

Fully manual (add / move / delete sites).

Key idea: every “ground” decision (biome, elevation, admin region, etc) is stored per cell, not per pixel.

Each cell has:

id (int).

siteX, siteY (float).

polygonVertices (list of Vec2, computed once).

elevation (float, continuous “earth level” including below sea level).

zoneLayerValues (map from layerId to zoneTypeId).

Maybe some caching: neighbors, centroid, bounding box.

1.2 Region layers (biome, admin, etc.)

We have N region layers, at least:

Layer 0: “Biome layer” (forest, desert, water, mountain, etc).

Layer 1: “Administrative layer” (country, city area, district, etc).

Possibly more, user defined.

Each region layer is:

id, name (eg "Biome", "Admin").

A set of zone types defined in the legend (see legend).

Data is stored per cell: each cell has exactly one zoneTypeId in that layer (or “none”).

So a cell might be:

Biome: FOREST.

Admin: CITY_A.

This lets you paint “forest over many cells” while still being able to see administrative boundaries, etc.

1.3 Paths

Paths are generic polylines with semantics defined by the legend:

Roads, rivers, currents, story links, cables, borders… whatever.

Each path has:

id.

pathTypeId (references a legend entry, e.g. “Primary road”, “Small river”).

vertices = list of control points, each:

x, y world coordinates.

Optional snap info: attachmentType (cell center / structure / free) and attachmentId.

segmentWeights (list of floats, one per segment, used for visual width or importance).

Optional attributes: name label, groupId (for membership in a higher-level object, eg “Road network of City A”).

By default, when adding vertices, they snap to cell centers (or nearest structure), so paths visually connect between Voronoi cell centers rather than edges.

1.4 Structures

Structures are simple shapes:

Circles, rectangles, later maybe icons.

Represent houses, buildings, landmarks, trees, or story nodes.

Each structure has:

id.

structureTypeId (from legend, eg “House”, “Tree”, “City marker”).

x, y (center coordinates).

Shape parameters:

For rectangles: width, height, rotation angle.

For circles: radius.

Optional snap:

Snaps to nearest path or structure for position and angle.

Optional groupId (for city grouping, forest grouping, etc).

Grouping is central for house→city or tree→forest logic.

1.5 Labels

Labels are generic text elements attached to anything or to arbitrary positions.

Each label:

id.

text (string).

Either:

targetType + targetId (cell, path, structure, group, region layer).

Or x, y absolute coordinates for free labels.

labelTypeId (from legend, to differentiate styling: “City name”, “Region name”, “Path name”, etc).

2. Legend and type system

Everything visual is driven by a legend that the user can edit.

2.1 Type categories

We have categories:

ZONE_TYPE (for region layers).

PATH_TYPE.

STRUCTURE_TYPE.

LABEL_TYPE.

Each type definition has:

id (unique integer).

category (one of the above).

name (eg “Forest”, “Primary road”, “Hamlet”, “City label”).

color (for map rendering).

Optional default properties:

Default stroke width, fill pattern, text size, etc.

For zone types: default fill style.

For path types: base path width, style (solid, dashed).

For structures: default shape and size.

For labels: default font size, alignment.

You can:

Add a new zone type: choose color and label, assign to a specific region layer.

Add new path types, structure types, label types similarly.

The legend can be visualized and exported in a corner of the map.

3. Elevation and sea level

Elevation is decoupled from zone types.

Each cell has one elevation value (float).

There is a global sea level slider that only affects rendering.

Underwater cells are not a separate zone type by default. Instead:

Rendering checks: cell.elevation < seaLevel → apply water color / overlay.

You can still define a “Sea” biome type in the biome layer if desired, but that is separate from the numeric elevation.

Later, shading for heights is derived from elevation (gradient, contour lines, etc).

4. Zoom and level of detail
4.1 Coordinate systems

World coordinates: everything is stored in 0..1 (or a fixed rectangle).

Screen coordinates: given by a view transform:

scale (zoom).

offsetX, offsetY (pan).

This allows:

Line strokes drawn with constant pixel thickness, independent of zoom.

Symbols that can scale or stay constant in screen size, depending on type.

4.2 LOD and merging

To manage house→city and trees→forest type merging, we define groups.

A group can represent:

A city (group of houses / buildings).

A forest (group of tree structures).

A more abstract “cluster”.

Each group:

id.

groupTypeId (from legend, eg “City group”, “Forest group”).

memberStructureIds (list).

Optional labelId.

Optional minZoomToExpand (threshold at which individual members appear instead of just the group symbol).

Rendering logic, simplified:

At low zoom (far away):

Only draw groups that are large enough, using their group symbol or a single region patch.

Hide individual trees / houses if they belong to a group and current zoom < minZoomToExpand.

At higher zoom (closer):

For each group, if zoom >= minZoomToExpand, hide group symbol and draw members instead.

User can define which structures belong to which group. The grouping logic for “this is a city” or “this is a forest” remains human-defined.

5. Editing modes and tools

The editor is divided into editing modes. At any time, only one is active.

Common interactions:

Left drag with “Pan” tool or middle mouse: pan view.

Mouse wheel or pinch: zoom (centered at cursor).

Right click or dedicated button: context menu on selection.

5.1 Mode: Voronoi sites

View seeds (sites) as points.

Tools:

Add site (click).

Move site (drag).

Delete site (click with modifier / delete key).

After modifications:

Recompute Voronoi cells, then retain per-cell data (zone values, elevation) by nearest-site mapping.

There may be several placement modes (random, even) as actions that create an initial set of sites.

5.2 Mode: Region painting (zones)

Pick:

region layer (Biome, Admin, or others).

zone type from legend (eg Forest, City A, etc).

Tools:

Paint cell by click or drag (flood fill constrained to layer).

Rectangle or lasso selection to assign a type to many cells.

Eyedropper tool to pick zone type from a cell.

The sea level slider is accessible somewhere but does not alter cell values, only visualization.

5.3 Mode: Elevation editing

Tools:

Adjust elevation of cells by:

Click and set numeric elevation.

Drag to apply a gradient or brush (simple brush tool).

Maybe an elevation picker like the color picker.

Visual aid:

Elevation overlay (shades of gray or color gradient).

Option to see contour lines.

5.4 Mode: Paths

Select a path type from legend (eg “Main road”, “Stream”).

Tools:

Create new path:

Click to create first vertex.

Click again along the way to add vertices.

Double-click or special key to end path.

Vertices snap by default to nearest cell center or structure.

Edit path:

Click path to select.

Drag a vertex to move.

Add vertex by clicking on a segment.

Delete vertex.

Change segment weight:

When a path is selected, per-segment UI (small handles) allows increasing or decreasing weight.

Change path type and label from a small property panel.

5.5 Mode: Structures

Select a structure type from legend (eg “House”, “Tree”, “Factory”, “City center”).

Tools:

Place structure:

Click to place at mouse position.

Optionally snap to nearest path and align with its tangent or snap to nearest structure.

Edit structure:

Drag to move.

Resize by handles.

Rotate rectangles.

Assign to a group:

Select multiple structures and assign them a new or existing group (eg “City A”).

Structure properties are editable through a side panel.

5.6 Mode: Labels

Select a label type from legend (eg “City name”, “Region label”).

Tools:

Attach label to:

A selected cell, path, structure, or group.

Or free-position label anywhere.

Edit text inline.

Adjust label anchor (where text is positioned relative to its target).

Option to follow path curvature for “road labels” later.

6. Legend UI and export

Legend panel shows:

A list grouped by category (Zones, Paths, Structures, Labels).

Each entry shows:

Color box.

Name.

Small icon representing type.

From this panel you can:

Add new type.

Rename type.

Change color.

Set default width, size, zoom behavior.

Legend export:

When exporting to SVG, legend can be rendered in a corner:

For each type: icon + color + name.

In the custom format, legend is serialized so that maps are fully self-contained.

7. Export formats
7.1 Custom human-readable format (probably JSON)

Something like:

{
  "version": 1,
  "worldBounds": [0, 0, 1, 1],
  "legend": {
    "zoneTypes": [...],
    "pathTypes": [...],
    "structureTypes": [...],
    "labelTypes": [...]
  },
  "regionLayers": [
    {
      "id": "biome",
      "name": "Biome",
      "zoneTypeIds": [ ... ]
    },
    {
      "id": "admin",
      "name": "Administrative",
      "zoneTypeIds": [ ... ]
    }
  ],
  "cells": [
    {
      "id": 0,
      "site": [0.123, 0.456],
      "polygon": [[x1, y1], [x2, y2], ...],
      "elevation": 0.12,
      "zones": {
        "biome": "FOREST",
        "admin": "CITY_A"
      }
    },
    ...
  ],
  "paths": [...],
  "structures": [...],
  "groups": [...],
  "labels": [...],
  "viewDefaults": {
    "seaLevel": 0.0
  }
}


Details can vary, but the idea is to be easy to read and hack by hand.

7.2 SVG export

One SVG grouped in layers:

Background (cells).

Region borders.

Paths.

Structures.

Labels.

Legend.

Each element carries class or data-* attributes matching type ids:

So you can restyle later in an editor or CSS.

Coordinate mapping from world to SVG coordinates is linear.

8. Processing project structure (tabs)

Later, when we write code, we will split into multiple tabs, for example:

Main.pde
setup(), draw(), load / save, main state, active tool.

Model.pde
Classes for MapModel, Cell, RegionLayer, Path, Structure, Group, Label.

Legend.pde
Legend management, type definitions.

Voronoi.pde
Data structures and functions for generating Voronoi cells from sites.

View.pde
Rendering functions for cells, paths, structures, labels, legend, LOD behavior.

Tools.pde
Tool classes or enums, mode switching, mouse handling per mode.

UI.pde
Simple buttons, sliders (sea level, zoom), panels.

Export.pde
JSON / SVG export and import helpers.

Utils.pde
Math, common helper functions, color utilities.

You will be able to tweak or rewrite any tab without touching the others too much.

9. Future generative modes (hooks only)

We keep this for later, but the design already allows:

“Fill missing biomes using Perlin noise, but never change cells that already have a user-assigned biome”.

“Generate a network of minor roads between existing cities”.

“Add small villages in suitable cells near a main road”.

Important constraint: every generative operation must be:

Deterministic (given a seed and current map).

Explicitly triggered (never automatic behind the scenes).

Non-destructive toward user-marked landmarks.